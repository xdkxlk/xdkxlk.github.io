title: Java位运算
author: xdkxlk
tags: []
mathjax: true
categories:
  - Java
date: 2018-11-26 21:12:00
---
# \>>>
是无符号右移，在高位补零  
右移运算符，它表示是将运算符左边的对象向右移动运算符右边指定的数，并且在高位补0，其实右移n位，就相当于除于2的n此方
```java
int a = 16;
int b = 2;
System.out.println(a >>> b); //结果是4 
```
# \>>
带符号右移运算符，它表示将运算符左边的运算对象，向右移动运算符右边指定的位数。如果是正数，在高位补零，如果是负数，则在高位补1
```java
int a = 16, c = -16;
int b = 2, d = 2;
System.out.println(a >> b); //结果是:4  
System.out.println(c >> d); //-4 
```
# <<
左移运算符，它表示是将运算符左边的对象，向左移动运算符右边指定的位数，并且在低位补零。其实，向左移n位，就相当于乘上2的n此方
```java
int a = 2;
int b = 2;
System.out.println(a << b); //结果是:8
```
# >>>=
a>>>=b 的意思是：a = a>>>b;

# 使用"与"代替"求余"
当b为2的n次方时，有如下替换公式：
$$
a \% b=a \& (b-1)当(b=2^n) 
$$
即：
$$
a \% 2^n = a \& (2^n-1)
$$
例如：14%8，取余数，就等于 14&7，相当于取出低位，而余数最大为7，14二进制为1110，8的二进制1000，8-1 = 7的二进制为0111，由于现在低位全为1，让其跟14做&运算，正好取出的是其低位上的余数。1110&0111=110即6=14%8；（此公式只适用b=2n，是因为可以保证b始终只有最高位为1，其他二进制位全部为0，减去1，之后，可以把高位1消除，其他位都为1，而与1做&运算，会保留原来的数。）  
这个算法应用在了 HashMap 求hash值所对应的数组的位置上  
```java
(n - 1) & hash
```
HashMap的大小一定为2的次方，所以可以这样代替求余