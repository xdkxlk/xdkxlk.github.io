<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="整体架构 名词解释 Broker消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker可以组成一个Kafka集群 Controller控制器其实就是一个broker，除了具有一般的broker的功能之外，还负责分区首领的选举 TopicKafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic Producer消息生产者，向Brok">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka 原理总结">
<meta property="og:url" content="http://xdkxlk.github.io/2018/11/20/Kafka-原理总结/index.html">
<meta property="og:site_name" content="xdkxlk&#39;s blog">
<meta property="og:description" content="整体架构 名词解释 Broker消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker可以组成一个Kafka集群 Controller控制器其实就是一个broker，除了具有一般的broker的功能之外，还负责分区首领的选举 TopicKafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic Producer消息生产者，向Brok">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://xdkxlk.github.io/img/F177wfgo2UQ4d8n1mb92.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/04aEjfXXGRKbPbSCF8Ij.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/siSKSfk2OXigsdkkbbV0.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/rOwA62vm5zO1bdYZ8x0w.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/q7p04qULlCcCCcu7kQIx.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/PR93bnGMlE2Uwf4mydnJ.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/Bqw6z5trOBOrP5u8K6R2.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/Zx4cGzpeOYzvTMnk51tG.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/j10By0LNRPButTzXPdMh.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/fZi2uULN2c3j4WmwrxWq.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/VcgYvQYp9oxafJ8W2iIk.png">
<meta property="og:image" content="http://xdkxlk.github.io/img/oHk32SnCWrIETyNMXUot.png">
<meta property="og:updated_time" content="2018-11-24T05:11:36.315Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kafka 原理总结">
<meta name="twitter:description" content="整体架构 名词解释 Broker消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker可以组成一个Kafka集群 Controller控制器其实就是一个broker，除了具有一般的broker的功能之外，还负责分区首领的选举 TopicKafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic Producer消息生产者，向Brok">
<meta name="twitter:image" content="http://xdkxlk.github.io/img/F177wfgo2UQ4d8n1mb92.png">






  <link rel="canonical" href="http://xdkxlk.github.io/2018/11/20/Kafka-原理总结/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Kafka 原理总结 | xdkxlk's blog</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?991eeb3d8d8aa5f453e1f8958536ac74";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xdkxlk's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">每一个不曾起舞的日子，都是对生命的辜负</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xdkxlk.github.io/2018/11/20/Kafka-原理总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdkxlk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xdkxlk's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kafka 原理总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-20 16:27:00" itemprop="dateCreated datePublished" datetime="2018-11-20T16:27:00+08:00">2018-11-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-24 13:11:36" itemprop="dateModified" datetime="2018-11-24T13:11:36+08:00">2018-11-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="/img/F177wfgo2UQ4d8n1mb92.png" alt="upload successful"></p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li>Broker<br>消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker可以组成一个Kafka集群</li>
<li>Controller<br>控制器其实就是一个broker，除了具有一般的broker的功能之外，还负责分区首领的选举</li>
<li>Topic<br>Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic</li>
<li>Producer<br>消息生产者，向Broker发送消息的客户端</li>
<li>Consumer<br>消息消费者，从Broker读取消息的客户端</li>
<li>ConsumerGroup<br>每个Consumer属于一个特定的Consumer Group，一条消息可以发送到多个不同的Consumer Group，但是一个Consumer Group中只能有一个Consumer能够消费该消息</li>
<li>Partition<br>物理上的概念，一个topic可以分为多个partition，每个partition内部是有序的</li>
<li>Segment<br>在物理上，一个partition的保存是由很多个segment文件组成的</li>
</ul>
<h2 id="保证"><a href="#保证" class="headerlink" title="保证"></a>保证</h2><ul>
<li>生产者发送到<strong>特定topic partition</strong> 的消息将按照发送的顺序处理。 也就是说，如果记录M1和记录M2由相同的生产者发送（<strong>成功发送到了broker</strong>），并先发送M1记录，那么M1的偏移比M2小，并在日志中较早出现（但这也意味着，如果有多个partition，这多个partiton之间的消息的顺序并不保证，<strong>而且实际情况下，由于可能出现的网络延迟和重试机制，需要一定的配置才能保证顺序</strong>）</li>
<li>一个消费者实例按照日志中的顺序查看记录</li>
<li>对于具有N个副本的主题，我们最多容忍N-1个服务器故障，从而保证不会丢失任何提交到日志中的记录（ISR）</li>
</ul>
<h2 id="Topic-amp-Partition"><a href="#Topic-amp-Partition" class="headerlink" title="Topic &amp; Partition"></a>Topic &amp; Partition</h2><p><img src="/img/04aEjfXXGRKbPbSCF8Ij.png" alt="upload successful"><br>对于每一个topic， Kafka集群都会维持一个分区日志，每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。追加是直接追加到partition的尾部，顺序写入，所以，写入的速度是很快的。<br>每一条消息被发送到broker中，会根据partition规则选择被存储到哪一个partition。如果partition规则设置的合理，所有消息可以均匀分布到不同的partition里，这样就实现了<strong>水平扩展</strong>。（如果一个topic对应一个文件，那这个文件所在的机器I/O将会成为这个topic的性能瓶颈，而partition解决了这个问题）<br>默认的partition的数目在 <code>server.properties</code> 配置，默认为1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># The default number of log partitions per topic. More partitions allow greater</span><br><span class="line"># parallelism for consumption, but this will also result in more files across</span><br><span class="line"># the brokers.</span><br><span class="line">num.partitions=1</span><br></pre></td></tr></table></figure></p>
<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="重要配置"><a href="#重要配置" class="headerlink" title="重要配置"></a>重要配置</h2><h2 id="元数据请求"><a href="#元数据请求" class="headerlink" title="元数据请求"></a>元数据请求</h2><p>生产者要自己负责把消息发送到正确的broker上面。直接发送数据到主分区的服务器上，不需要经过任何中间路由。位置通过<strong>元数据请求</strong>获得，客户端一般会将这些信息缓存起来，并时不时的刷新元数据（通过 <code>metadata.max.age.ms</code> 配置）。如果客户端收到了“非首领”错误，那么在重新尝试发送的时候，会先刷新元数据。</p>
<h2 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h2><p>kafka支持消息的重试，由 producer的 <code>retries</code> 控制，默认为0。若设置大于0的值，则客户端会将发送失败的记录重新发送，尽管这些记录有可能是暂时性的错误。<strong>请注意，这种 retry 与客户端收到错误信息之后重新发送记录并无区别。</strong><br>还有一个配置是 <code>max.in.flight.requests.per.connection</code> 默认为5。代表在发生阻塞之前，客户端的一个连接上允许出现未确认请求的最大数量。<br>所以，如果在某些场景下，要求消息是有序的，那么这种场景下消息是否写入成功也很关键。所以，<code>retries</code> 不建议设为0。又由于重试的原因，<code>max.in.flight.requests.per.connection</code> 应该设为1，保证不会在重试的时候，后面的消息先发送成功了。<strong>但是这样的配置会严重影响生产者的吞吐量</strong><br>最终配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retries = 3 #设为大于0的数字</span><br><span class="line">max.in.flight.requests.per.connection = 1</span><br></pre></td></tr></table></figure></p>
<h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="重要配置-1"><a href="#重要配置-1" class="headerlink" title="重要配置"></a>重要配置</h2><h2 id="pull-amp-push"><a href="#pull-amp-push" class="headerlink" title="pull &amp; push"></a>pull &amp; push</h2><p>kafka采用的策略是：producer 把数据 push 到 broker，然后 consumer 从 broker 中 pull 数据。<br>所以，消费者要不停的进行轮询<br>消费者采用pull的原因：</p>
<ul>
<li>当消费速率低于生产速率时，push会使consumer不堪重负（本质上类似于拒绝服务攻击）</li>
<li>pull-based 系统有一个很好的特性， 那就是当 consumer 速率落后于 producer 时，可以在适当的时间赶上来</li>
<li>push-based producer拿不准消费者能处理多大的数据。是一次发送一条数据呢，还是一次性发多条数据呢</li>
<li>pull-based consumer 总是将所有可用的（或者达到配置的最大长度）消息 </li>
</ul>
<h2 id="分区和消费者"><a href="#分区和消费者" class="headerlink" title="分区和消费者"></a>分区和消费者</h2><p>在一个群组中，一个分区最多对应一个消费者，所以如果同一个群组中的消费者大于分区的数量，那么就会有消费者处于闲置状态，所以，<strong>不要让消费者数量超过主题分区的数量</strong></p>
<h2 id="再均衡"><a href="#再均衡" class="headerlink" title="再均衡"></a>再均衡</h2><p>分区的所有权由一个消费者转移到另一个消费者，这样的被称为再均衡。再均衡期间，整个群组会有一小段时间不可用，同时，分区重新分配给另一个消费者之后，消费者当前的读取状态会丢失（要做到安全的再均衡，offset提交）</p>
<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ul>
<li>组成员发生变更(新consumer加入组、已有consumer主动离开组或已有consumer崩溃了——这两者的区别后面会谈到)</li>
<li>订阅主题数发生变更——这当然是可能的，如果你使用了正则表达式的方式进行订阅，那么新建匹配正则表达式的topic就会触发rebalance</li>
<li>订阅主题的分区数发生变更</li>
</ul>
<h3 id="加入过程"><a href="#加入过程" class="headerlink" title="加入过程"></a>加入过程</h3><p>消费者想群组协调器（它其实就是一个broker）发送 <code>JoinGroup</code> 请求，第一个加入群组的消费者成为“群主”。群主从协调器那儿获得成员的列表，并负责给每一个消费者分配分区。<br>kafka将分区的分配的权利下放给消费者，提高了扩展性。</p>
<h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><p>由 <code>partition.assignment.strategy</code> 指定，默认是 <code>range</code>  还有一个 <code>roundRobin</code> 策略。  </p>
<ul>
<li>range<br>C1、C2订阅T1、T2，每个主题又3个分区。那么C1可能被分为T1、T2的0、1两个分区，C2分为T1、T2的2分区</li>
<li>roundRobin<br>这个就是把主题的分区逐个分配给消费者，各个消费者的分区数量都会差不多（最多差一个分区）</li>
</ul>
<h1 id="消息交付语义"><a href="#消息交付语义" class="headerlink" title="消息交付语义"></a>消息交付语义</h1><ul>
<li>At most once——消息可能会丢失但绝不重传。</li>
<li>At least once——消息可以重传但绝不丢失。</li>
<li>Exactly once——这正是人们想要的, 每一条消息只被传递一次。</li>
</ul>
<p><strong>在kafka中分为生产者和消费者两个部分</strong></p>
<h2 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h2><p>如果一个 producer 在试图发送消息的时候发生了网络故障， 则不确定网络错误发生在消息提交之前还是之后。<br>0.11.0.0 之前的版本中, 如果 producer 没有收到表明消息已经被提交的响应, 那么 producer 除了将消息重传之外别无选择。 这里提供的是 <code>at-least-once</code> 的消息交付语义。<br>从 0.11.0.0 版本开始，broker 给每个 producer 都分配了一个 ID ，并且 producer 给每条被发送的消息分配了一个序列号来避免产生重复的消息（<code>幂等性</code>）。（<code>Exactly once</code>）<br>同时，也是从 0.11.0.0 版本开始, producer 新增了使用类似事务性的语义将消息发送到多个 topic partition 的功能，要么所有的消息都被成功的写入到了 log，要么一个都没写进去（<code>Exactly once</code>）<br><strong>但是如要实现幂等性和事务还需要其他的配置</strong></p>
<h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h2><p>Consumer 先读取消息，然后将它的位置保存到 log 中，最后再对消息进行处理。（<code>at-most-once</code>）<br>Consumer 可以先读取消息，然后处理消息，最后再保存它的位置。（<code>at-least-once</code>）在许多应用场景中，消息都设有一个主键，所以更新操作是<code>幂等</code>的（相同的消息接收两次时，第二次写入会覆盖掉第一次写入的记录）。  </p>
<h3 id="如何实现-exactly-once"><a href="#如何实现-exactly-once" class="headerlink" title="如何实现 exactly once ?"></a>如何实现 exactly once ?</h3><ul>
<li>当从一个 kafka topic 中消费并输出到另一个 topic<br>可以使用事务型 producer</li>
<li>写入外部系统的应用场景<br>解决这一问题的经典方法是在 consumer offset 的存储和 consumer 的输出结果的存储之间引入 two-phase commit。<del>（这个后面再写写代码研究）</del></li>
</ul>
<h1 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h1><p>创建副本的单位是 topic 的 partition ，正常情况下， 每个partition都有一个 leader 和零或多个 followers 。<br>分为<strong>首领副本(leader)</strong> 和 <strong>跟随者副本(followers)</strong>  </p>
<h2 id="首领副本"><a href="#首领副本" class="headerlink" title="首领副本"></a>首领副本</h2><ul>
<li>处理所有的读写操作</li>
<li>维护ISR列表（搞清楚哪些跟随着跟自己的数据是同步的）</li>
</ul>
<h2 id="跟随者副本"><a href="#跟随者副本" class="headerlink" title="跟随者副本"></a>跟随者副本</h2><p>像普通的 consumer 那样从 leader 节点那里拉取消息并保存在自己的日志文件中，且这些请求是有序的。例如，先请求消息1，接着请求消息2，在收到2这个消息的请求之前，是不会发送消息3的。</p>
<h2 id="判断节点是否存活"><a href="#判断节点是否存活" class="headerlink" title="判断节点是否存活"></a>判断节点是否存活</h2><ul>
<li>节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接。</li>
<li>如果节点是个 follower ，它必须能及时的同步 leader 的写操作，并且延时不能太久。</li>
</ul>
<p>如果有节点挂掉了, 或是写超时, 或是心跳超时, leader 就会把它从同步副本列表（ISR）中移除。 同步超时和写超时的时间由 <code>replica.lag.time.max.ms</code> 配置确定。</p>
<h2 id="Quorums，ISR，首领副本（Leader）选举"><a href="#Quorums，ISR，首领副本（Leader）选举" class="headerlink" title="Quorums，ISR，首领副本（Leader）选举"></a>Quorums，ISR，首领副本（Leader）选举</h2><h3 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h3><p>如果选择写入时候需要保证一定数量的副本写入成功，读取时需要保证读取一定数量的副本，读取和写入之间有重叠。这样的读写机制称为 Quorum。<br>这种权衡的一种常见方法是对提交决策和 leader 选举使用多数投票机制。<strong>Kafka 没有采取这种方式</strong>，但是我们还是要研究一下这种投票机制，来理解其中蕴含的权衡。假设我们有2f + 1个副本，如果在 leader 宣布消息提交之前必须有f+1个副本收到 该消息，并且如果我们从这至少f+1个副本之中，有着最完整的日志记录的 follower 里来选择一个新的 leader，那么在故障次数少于f的情况下，选举出的 leader 保证具有所有提交的消息。这是因为在任意f+1个副本中，至少有一个副本一定包含 了所有提交的消息。该副本的日志将是最完整的，因此将被选为新的 leader。这个算法都必须处理许多其他细节（例如精确定义怎样使日志更加完整，确保在 leader down 掉期间, 保证日志一致性或者副本服务器的副本集的改变），但是现在我们将忽略这些细节。(Zookeeper)<br><strong>这种大多数投票方法有一个非常好的优点：</strong>延迟是取决于最快的服务器。也就是说，如果副本数是3，则备份完成的等待时间取决于最快的 Follwer 。<br><strong>“少数服从多数”的方式也有一些劣势</strong>，为了保证leader选举的正常进行，它所能容忍的失败的follower数比较少，如果要容忍1个follower挂掉，那么至少要3个以上的副本，如果要容忍2个follower挂掉，必须要有5个以上的副本。在一个系统中，仅仅靠冗余来避免单点故障是不够的，但是每写5次，对磁盘空间需求是5倍， 吞吐量下降到 1/5，这对于处理海量数据问题是不切实际的。<strong>这可能是为什么 quorum 算法更常用于共享集群配置（如 ZooKeeper ）， 而不适用于原始数据存储的原因</strong>。</p>
<h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>Kafka 动态维护了一个同步状态的备份的集合 （a set of in-sync replicas）， 简称 ISR ，在这个集合中的节点都是和 leader 保持高度一致的，只有这个集合的成员才有资格被选举为 leader（<code>unclean.leader.election.enable=false</code>）。 在这种模式下，对于f+1个副本，一个Kafka topic能在保证不丢失已经commit消息的前提下容忍f个副本的失败。<br><strong>而选择哪个作为新的leader是由controller来决定的</strong></p>
<h2 id="复制原理和同步方式"><a href="#复制原理和同步方式" class="headerlink" title="复制原理和同步方式"></a>复制原理和同步方式</h2><p>对于每个partition，有HW，和 LEO<br><img src="/img/siSKSfk2OXigsdkkbbV0.png" alt="upload successful"><br>LEO，LogEndOffset的缩写，表示每个partition的log最后一条Message的位置。HW是HighWatermark的缩写，是指consumer能够看到的此partition的位置。<br>对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broker的读取请求，没有HW的限制。<br><img src="/img/rOwA62vm5zO1bdYZ8x0w.png" alt="upload successful"><br>由此可见，Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的follower都复制完，这条消息才会被commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，follower异步的从leader复制数据，数据只要被leader写入log就被认为已经commit，这种情况下如果follower都还没有复制完，落后于leader时，突然leader宕机，则会丢失数据。而Kafka的这种使用ISR的方式则很好的均衡了确保数据不丢失以及吞吐率。</p>
<h2 id="Unclean-leader-选举-如果节点全挂了？"><a href="#Unclean-leader-选举-如果节点全挂了？" class="headerlink" title="Unclean leader 选举: 如果节点全挂了？"></a>Unclean leader 选举: 如果节点全挂了？</h2><p><code>unclean.leader.election.enable</code>默认为false<br><strong>请注意，Kafka 对于数据不会丢失的保证，是基于至少一个节点在保持同步状态，一旦分区上的所有备份节点都挂了，就无法保证了。</strong>  </p>
<ul>
<li>等待一个 ISR 的副本重新恢复正常服务，并选择这个副本作为领 leader （它有极大可能拥有全部数据）。</li>
<li>选择第一个重新恢复正常服务的副本（不一定是 ISR 中的）作为leader。 </li>
</ul>
<h2 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h2><ul>
<li>kafka要尽量保证在broker之间平均的分配副本</li>
<li>确保每个分区的副本在不同的broker上</li>
<li>如果为broker指定了机架，那么尽量把每一个分区副本放在不同的机架上</li>
</ul>
<p><img src="/img/q7p04qULlCcCCcu7kQIx.png" alt="upload successful"><br>现有6个broker，打算创建一个包含10个分区的主题，且复制系数为3，那么kafka就有30个分区副本。  </p>
<h3 id="没有配置机架的情况"><a href="#没有配置机架的情况" class="headerlink" title="没有配置机架的情况"></a>没有配置机架的情况</h3><ul>
<li>先随机选择一个broker(4)</li>
<li>使用轮询方式给每个broker分配分区来确定首领分区的位置<br>首领分区0 -&gt; broker4，首领分区1 -&gt; broker5，首领分区2 -&gt; broker0，等等</li>
<li>从首领分区开始，依次分配跟随着副本。<br>分区0首领在broker4上，那么follower0-0在broker5，follower0-1在broker0，等等。</li>
</ul>
<h3 id="配置了机架的情况"><a href="#配置了机架的情况" class="headerlink" title="配置了机架的情况"></a>配置了机架的情况</h3><p>假设 broker0、1、2在同一个机架上，broker3、4、5在同一个机架上。也是用轮序的方式分配，只不过轮序的顺序是按照机架交错的，0、3、1、4、2、5</p>
<h1 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h1><p>控制器其实就是一个broker，只不过在一般broker之外，还有分区首领选择的功能。  </p>
<h2 id="controller的选择"><a href="#controller的选择" class="headerlink" title="controller的选择"></a>controller的选择</h2><p>利用zookeeper，创建一个 /controller 的临时节点让自己成为控制器。如果挂掉了，那么其他broker会收到通知，又再一次创建 /controller 节点，竞争成为新的控制器</p>
<h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><p>通过 <code>controller_epoch</code> 解决。<br>broker收到了较旧的 epoch，就会忽略它们</p>
<h2 id="broker离开"><a href="#broker离开" class="headerlink" title="broker离开"></a>broker离开</h2><p>当发现有broker离开集群，那么控制器就会找出失去了首领的那些分区，并遍历这些分区，确定新的首领副本，发送首领变更的请求</p>
<h2 id="broker加入"><a href="#broker加入" class="headerlink" title="broker加入"></a>broker加入</h2><p>当新的broker加入的时候，控制器检查新加入的broker是否有现有分区的副本，如果有，就通知其他broker,并且新加入的broker开始复制消息</p>
<h1 id="可靠性和持久性保证"><a href="#可靠性和持久性保证" class="headerlink" title="可靠性和持久性保证"></a>可靠性和持久性保证</h1><p>producer 设置 <code>ack</code>:</p>
<ul>
<li><code>ack = 0</code> 不等待broker返回确认消息</li>
<li><code>ack = 1</code> leader保存成功返回</li>
<li><code>ack = -1(all)</code> 所有备份都保存成功返回</li>
</ul>
<p>这里面要注意的是 <code>所有备份都保存成功返回</code> 并不意味着所有的副本都写入了消息。这个跟 broker 的 <code>min.insync.replicas</code> 有关，其默认为1。那么有可能ISR列表中有些副本没有写入。<br>这里有一个经典的配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">topic 的 replication = 3</span><br><span class="line">min.insync.replicas = 2</span><br><span class="line">producer 的 ack = -1</span><br></pre></td></tr></table></figure></p>
<p>这将确保如果大多数副本没有写入producer则抛出异常（NotEnoughReplicasExceptoin）。</p>
<h2 id="高可靠性配置"><a href="#高可靠性配置" class="headerlink" title="高可靠性配置"></a>高可靠性配置</h2><ul>
<li>topic的配置：replication.factor&gt;=3, 即副本数至少是3个；2&lt;=min.insync.replicas&lt;=replication.factor</li>
<li>broker的配置：leader的选举条件 unclean.leader.election.enable=false</li>
<li>producer的配置：request.required.acks=-1(all)</li>
</ul>
<h2 id="acks-1"><a href="#acks-1" class="headerlink" title="acks=1"></a>acks=1</h2><p>producer发送数据到leader，leader写本地日志成功，返回客户端成功；此时ISR中的副本还没有来得及拉取该消息，leader就宕机了，那么此次发送的消息就会丢失。<br><img src="/img/PR93bnGMlE2Uwf4mydnJ.png" alt="upload successful"></p>
<h2 id="acks-1-1"><a href="#acks-1-1" class="headerlink" title="acks=-1"></a>acks=-1</h2><p>replication.factor&gt;=2 且 min.insync.replicas&gt;=2的情况下，不会丢失数据<br><img src="/img/Bqw6z5trOBOrP5u8K6R2.png" alt="upload successful"></p>
<p><img src="/img/Zx4cGzpeOYzvTMnk51tG.png" alt="upload successful"></p>
<h2 id="HW的进一步探讨"><a href="#HW的进一步探讨" class="headerlink" title="HW的进一步探讨"></a>HW的进一步探讨</h2><p><img src="/img/j10By0LNRPButTzXPdMh.png" alt="upload successful"><br>如上图，某个topic的某partition有三个副本，分别为A、B、C。A作为leader肯定是LEO最高，B紧随其后，C机器由于配置比较低，网络比较差，故而同步最慢。这个时候A机器宕机，这时候如果B成为leader，假如没有HW，在A重新恢复之后会做同步(makeFollower)操作，在宕机时log文件之后直接做追加操作，而假如B的LEO已经达到了A的LEO，会产生数据不一致的情况，所以使用HW来避免这种情况。<br><strong>A在做同步操作的时候，先将log文件截断到之前自己的HW的位置，即3，之后再从B中拉取消息进行同步。</strong><br>如果失败的follower恢复过来，它首先将自己的log文件截断到上次checkpointed时刻的HW的位置，之后再从leader中同步消息。leader挂掉会重新选举，新的leader会发送“指令”让其余的follower截断至自身的HW的位置然后再拉取新的消息。</p>
<h1 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h1><p><del>个人觉得Kafka官方文档没有更新到最新的版本。因为它说存储的文件是 .kafka 结尾的，然而，我实际上看见的文件格式是 .index .log</del><br>物理上一个topic由多个partition组成（如果设置了多个partition），一个partition就是一个文件夹，partition的名称规则为：topic名称+有序序号，第一个序号从0开始计。partition是实际物理上的概念，而topic是逻辑上的概念。<br>而partition又是以segment存储的，segment是一个个小的文件。</p>
<h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 单个日志段文件最大大小</span><br><span class="line">log.segment.bytes = 1073741824</span><br><span class="line"># 从文件系统中删除一个日志段文件前的保留时间</span><br><span class="line">log.segment.delete.delay.ms = 60000</span><br><span class="line"></span><br><span class="line"># 新日志段轮转时间间隔</span><br><span class="line">log.roll.hours = 168</span><br><span class="line">log.roll.ms = null</span><br></pre></td></tr></table></figure>
<h2 id="segment存储"><a href="#segment存储" class="headerlink" title="segment存储"></a>segment存储</h2><p>segment文件由两部分组成，分别为 “.index” 文件和 “.log” 文件，分别表示为segment索引文件和数据文件。这两个文件的命令规则为：partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值，数值大小为64位，20位数字字符长度，没有数字用0填充，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000.index</span><br><span class="line">00000000000000000000.log</span><br><span class="line">00000000000000170410.index</span><br><span class="line">00000000000000170410.log</span><br><span class="line">00000000000000239430.index</span><br><span class="line">00000000000000239430.log</span><br></pre></td></tr></table></figure></p>
<p>他们之间的关系如下<br><img src="/img/fZi2uULN2c3j4WmwrxWq.png" alt="upload successful"><br>如上图，“.index” 索引文件存储大量的元数据，“.log” 数据文件存储大量的消息，索引文件中的元数据指向对应数据文件中message的物理偏移地址。其中以“.index”索引文件中的元数据 [3, 348] 为例，在“.log”数据文件表示第3个消息，即在全局partition中表示 170410+3=170413 个消息，该消息的物理偏移地址为348。<br>那么如何从partition中通过offset查找message呢？<br>以上图为例，读取offset=170418的消息</p>
<ul>
<li>首先查找segment文件，其中00000000000000000000.index为最开始的文件，第二个文件为00000000000000170410.index（起始偏移为170410+1=170411），而第三个文件为00000000000000239430.index（起始偏移为239430+1=239431），所以这个offset=170418就落到了第二个文件之中。其他后续文件可以依次类推，以其实偏移量命名并排列这些文件</li>
<li>然后根据二分查找法就可以快速定位到具体文件位置。其次根据00000000000000170410.index文件中的 [8,1325] 定位到00000000000000170410.log文件中的1325的位置进行读取。</li>
</ul>
<h1 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h1><h2 id="几个重要的配置"><a href="#几个重要的配置" class="headerlink" title="几个重要的配置"></a>几个重要的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 下面的都是默认值</span><br><span class="line">log.cleaner.enable = true </span><br><span class="line">log.cleanup.policy = delete</span><br><span class="line"># 日志中脏数据清理比例</span><br><span class="line">log.cleaner.min.cleanable.ratio = 0.5</span><br><span class="line"># 消息在日志中保持未压缩的最短时间。 仅适用于正在压缩的日志</span><br><span class="line">log.cleaner.min.compaction.lag.ms = 0</span><br></pre></td></tr></table></figure>
<h2 id="清理策略"><a href="#清理策略" class="headerlink" title="清理策略"></a>清理策略</h2><p>压缩策略由 <code>log.cleanup.policy</code> 指定。清理策略分为 <code>delete</code>和 <code>compact</code></p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p> <code>delete</code> 就是单纯的删除。是默认的策略，跟它相关的配置有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log.retention.bytes 默认 -1</span><br><span class="line">log.retention.ms / log.retention.hours / log.retention.minutes</span><br><span class="line"></span><br><span class="line"># 从文件系统中删除一个日志段文件前的保留时间</span><br><span class="line">log.segment.delete.delay.ms = 60000</span><br><span class="line"></span><br><span class="line"># 日志清理器检查是否有日志符合删除的频率</span><br><span class="line">log.retention.check.interval.ms = 300000</span><br></pre></td></tr></table></figure></p>
<p>删除的时候，会先将segment标记为 .delete ，然后在 <code>log.segment.delete.delay.ms</code> 之后，由另外一个定时器线程删除</p>
<h3 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h3><p><code>compact</code> 是对于数据进行压缩清理<br><img src="/img/VcgYvQYp9oxafJ8W2iIk.png" alt="upload successful"><br>日志分为两个部分，log tail是已经压缩了的日志，log head是还没有压缩的日志。对于上面的这个，36、37、38都是指的是38这个位置。<br><code>compact</code> 其实就是保留最新的 k-v 键值对，示意图如下<br><img src="/img/oHk32SnCWrIETyNMXUot.png" alt="upload successful"><br>如果我们要删除一个数据，那么要经过下面几个过程：</p>
<ul>
<li>程序发送包含该键且值为null的消息</li>
<li>进行常规清理，只保留为null的消息（墓碑消息，tomestone）</li>
<li>墓碑消息会保留一段时间</li>
<li>假如消费者在通过kafka进行数据处理的时候，发现key为null，就应该知道，这个数据被删除了</li>
<li>到时间之后，移除墓碑消息</li>
</ul>
<p>墓碑移除的时间由 <code>log.cleaner.delete.retention.ms</code> 控制，默认24小时<br>清理的时候，<strong>清理线程会选择污浊率较高的分区进行清理</strong>（log head占总分区的比例）。<code>log.cleaner.min.compaction.lag.ms</code> 默认为0，所以默认不会清理最后一个活动的segment。故，可以通过配置 <code>log.cleaner.min.compaction.lag.ms</code>，保证消息在配置的时长内不被压缩。<strong>活动的 segment 是不会被压缩的，即使它保存的消息的滞留时长已经超过了配置的最小压缩时间长。</strong>扫描的频率由 <code>log.cleaner.backoff.ms</code> 控制</p>
<h1 id="一个生产环境服务器配置示例"><a href="#一个生产环境服务器配置示例" class="headerlink" title="一个生产环境服务器配置示例"></a>一个生产环境服务器配置示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># ZooKeeper</span><br><span class="line">zookeeper.connect=[list of ZooKeeper servers]</span><br><span class="line"> </span><br><span class="line"># Log configuration</span><br><span class="line">num.partitions=8</span><br><span class="line">default.replication.factor=3</span><br><span class="line">log.dir=[List of directories. Kafka should have its own dedicated disk(s) or SSD(s).]</span><br><span class="line"> </span><br><span class="line"># Other configurations</span><br><span class="line">broker.id=[An integer. Start with 0 and increment by 1 for each new broker.]</span><br><span class="line">listeners=[list of listeners]</span><br><span class="line">auto.create.topics.enable=false</span><br><span class="line">min.insync.replicas=2</span><br><span class="line">queued.max.requests=[number of concurrent requests]</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://kafka.apachecn.org/documentation.html" target="_blank" rel="noopener">kafka1.0 中文文档</a><br><a href="https://blog.csdn.net/u013256816/article/details/71091774" target="_blank" rel="noopener">kafka数据可靠性深度解读</a><br><a href="https://www.zybuluo.com/tinadu/note/949867" target="_blank" rel="noopener">Kafka设计解析（八）- Kafka事务机制与Exactly Once语义实现原理</a><br><a href="https://blog.csdn.net/u013256816/article/details/80487758" target="_blank" rel="noopener">Kafka日志清理之Log Compaction</a><br><a href="https://my.oschina.net/abcfy2/blog/634973" target="_blank" rel="noopener">Kafka配置消息保存时间的方法</a><br><a href="https://www.iteblog.com/archives/1616.html" target="_blank" rel="noopener">Kafka日志删除源码分析</a><br><a href="https://www.jianshu.com/p/aa274f8fe00f" target="_blank" rel="noopener">Kafka源码分析-Content Table</a><br><a href="http://www.cnblogs.com/huxi2b/p/6223228.html" target="_blank" rel="noopener">Kafka消费组(consumer group)</a><br><a href="http://matt33.com/" target="_blank" rel="noopener">Matt’s Blog (挺厉害的，对于kafka理解很深)</a></p>

      
    </div>

    

    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>xdkxlk</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xdkxlk.github.io/2018/11/20/Kafka-原理总结/" title="Kafka 原理总结">http://xdkxlk.github.io/2018/11/20/Kafka-原理总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/19/ThreadLocal/" rel="next" title="ThreadLocal">
                <i class="fa fa-chevron-left"></i> ThreadLocal
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MTIzNS8xNzc4Mw=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xdkxlk</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#整体架构"><span class="nav-number">1.</span> <span class="nav-text">整体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#名词解释"><span class="nav-number">1.1.</span> <span class="nav-text">名词解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保证"><span class="nav-number">1.2.</span> <span class="nav-text">保证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Topic-amp-Partition"><span class="nav-number">1.3.</span> <span class="nav-text">Topic &amp; Partition</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#生产者"><span class="nav-number">2.</span> <span class="nav-text">生产者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重要配置"><span class="nav-number">2.1.</span> <span class="nav-text">重要配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元数据请求"><span class="nav-number">2.2.</span> <span class="nav-text">元数据请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序保证"><span class="nav-number">2.3.</span> <span class="nav-text">顺序保证</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消费者"><span class="nav-number">3.</span> <span class="nav-text">消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重要配置-1"><span class="nav-number">3.1.</span> <span class="nav-text">重要配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pull-amp-push"><span class="nav-number">3.2.</span> <span class="nav-text">pull &amp; push</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分区和消费者"><span class="nav-number">3.3.</span> <span class="nav-text">分区和消费者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再均衡"><span class="nav-number">3.4.</span> <span class="nav-text">再均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#触发条件"><span class="nav-number">3.4.1.</span> <span class="nav-text">触发条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加入过程"><span class="nav-number">3.4.2.</span> <span class="nav-text">加入过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配策略"><span class="nav-number">3.4.3.</span> <span class="nav-text">分配策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息交付语义"><span class="nav-number">4.</span> <span class="nav-text">消息交付语义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者-1"><span class="nav-number">4.1.</span> <span class="nav-text">生产者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消费者-1"><span class="nav-number">4.2.</span> <span class="nav-text">消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现-exactly-once"><span class="nav-number">4.2.1.</span> <span class="nav-text">如何实现 exactly once ?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Replication"><span class="nav-number">5.</span> <span class="nav-text">Replication</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#首领副本"><span class="nav-number">5.1.</span> <span class="nav-text">首领副本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跟随者副本"><span class="nav-number">5.2.</span> <span class="nav-text">跟随者副本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断节点是否存活"><span class="nav-number">5.3.</span> <span class="nav-text">判断节点是否存活</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Quorums，ISR，首领副本（Leader）选举"><span class="nav-number">5.4.</span> <span class="nav-text">Quorums，ISR，首领副本（Leader）选举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Quorum"><span class="nav-number">5.4.1.</span> <span class="nav-text">Quorum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ISR"><span class="nav-number">5.4.2.</span> <span class="nav-text">ISR</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制原理和同步方式"><span class="nav-number">5.5.</span> <span class="nav-text">复制原理和同步方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unclean-leader-选举-如果节点全挂了？"><span class="nav-number">5.6.</span> <span class="nav-text">Unclean leader 选举: 如果节点全挂了？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分区分配"><span class="nav-number">5.7.</span> <span class="nav-text">分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#没有配置机架的情况"><span class="nav-number">5.7.1.</span> <span class="nav-text">没有配置机架的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置了机架的情况"><span class="nav-number">5.7.2.</span> <span class="nav-text">配置了机架的情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制器"><span class="nav-number">6.</span> <span class="nav-text">控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#controller的选择"><span class="nav-number">6.1.</span> <span class="nav-text">controller的选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#脑裂"><span class="nav-number">6.2.</span> <span class="nav-text">脑裂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#broker离开"><span class="nav-number">6.3.</span> <span class="nav-text">broker离开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#broker加入"><span class="nav-number">6.4.</span> <span class="nav-text">broker加入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可靠性和持久性保证"><span class="nav-number">7.</span> <span class="nav-text">可靠性和持久性保证</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#高可靠性配置"><span class="nav-number">7.1.</span> <span class="nav-text">高可靠性配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#acks-1"><span class="nav-number">7.2.</span> <span class="nav-text">acks=1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#acks-1-1"><span class="nav-number">7.3.</span> <span class="nav-text">acks=-1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HW的进一步探讨"><span class="nav-number">7.4.</span> <span class="nav-text">HW的进一步探讨</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件存储"><span class="nav-number">8.</span> <span class="nav-text">文件存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相关配置"><span class="nav-number">8.1.</span> <span class="nav-text">相关配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#segment存储"><span class="nav-number">8.2.</span> <span class="nav-text">segment存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#日志清理"><span class="nav-number">9.</span> <span class="nav-text">日志清理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#几个重要的配置"><span class="nav-number">9.1.</span> <span class="nav-text">几个重要的配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#清理策略"><span class="nav-number">9.2.</span> <span class="nav-text">清理策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#delete"><span class="nav-number">9.2.1.</span> <span class="nav-text">delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compact"><span class="nav-number">9.2.2.</span> <span class="nav-text">compact</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一个生产环境服务器配置示例"><span class="nav-number">10.</span> <span class="nav-text">一个生产环境服务器配置示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">11.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xdkxlk</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
